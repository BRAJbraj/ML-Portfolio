# -*- coding: utf-8 -*-
"""practice_pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qw1ZmIof0aa1Iz2KwBI5yrj7hR5Uhe0q
"""

import pandas as pd
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
import numpy as np
from sklearn.preprocessing import FunctionTransformer
from sklearn.compose import ColumnTransformer

data = pd.DataFrame({
"sqft": [800, 1000, 1200, 1500, 1800],
"price": [120000, 150000, 170000, 210000, 250000],
"city_code": [1, 2, 1, 3, 2]
})

def log1p(X):
  return np.log(1+X)

log_transformer=FunctionTransformer(log1p, feature_names_out='one-to-one')

pipeline_log_sqft=Pipeline([('log_sqft',log_transformer)])

pipe=ColumnTransformer([('pipeline',pipeline_log_sqft,['sqft'])]).set_output(transform="pandas")
pipe.fit_transform(data)

"""EVEL 2: Adding Derived Features with a Custom FunctionTransformer Returning a Wider DataFrame

Goal:

Start from a DataFrame with numeric + categorical columns.
Use a FunctionTransformer that:
Keeps original columns.
Adds two new engineered features: a. sqft_log = log1p(sqft) b. bedrooms_per_1000_sqft = bedrooms / (sqft / 1000)
Provide correct feature names via feature_names_out.
(Optional stretch) After adding features, scale only the numeric ones (except the categorical city_code) via a ColumnTransformer + StandardScaler.
"""

# Level 2
data2 = pd.DataFrame({
"sqft": [800, 1000, 1200, 1500, 1800],
"bedrooms": [2, 2, 3, 3, 4],
"age": [10, 5, 20, 15, 8],
"price": [120000, 150000, 170000, 210000, 250000],
"city_code": [1, 2, 1, 3, 2]
})

X=data2(drop='price').copy()
y=data2['price']

#level 3



"""exercise"""

import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin

df = pd.DataFrame({
    'text': ['hello', 'machine learning', 'scikit', 'AI']
})

class textlengthcalculator(BaseEstimator, TransformerMixin):
    def __init__(self,text='text'):
        self.text=text

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X=X.copy()
        X['text_length']=X[self.text].str.len()
        return X

obj=textlengthcalculator()
obj.transform(df)

"""Takes a dataset with a "text" column.

Creates a new column "text_length" = number of characters in the text.

Returns the transformed DataFrame.

level up:
ðŸ”¹ Exercise: BMITransformer

Youâ€™ll build a transformer that:

Takes a DataFrame with "weight" (kg) and "height" (m) columns.

Creates a new column "BMI" using the formula:

BMI
=
weight
height
2
BMI=
height
2
weight
	â€‹


Allows the user to set custom column names for weight/height in __init__.

Optionally (extra challenge): add a parameter drop_original (default False) that, if set to True, removes the weight/height columns after creating BMI.
"""

import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin
import numpy as np

df = pd.DataFrame({
    'weight': [60, 72, 90],
    'height': [1.65, 1.80, 1.75]
})

class BMIcalculator(BaseEstimator, TransformerMixin):
    def __init__(self, weight_col='weight', height_col='height', drop_original=False):
        self.weight_col = weight_col
        self.height_col = height_col
        self.drop_original = drop_original

    def fit(self, X, y=None):
        return self

    def transform(self, X, y=None):
        X = X.copy()
        X['BMI'] = (X[self.weight_col] * 1.0) / (X[self.height_col] ** 2)
        if self.drop_original:
            X = X[['BMI']]
        return X
obj=BMIcalculator()
obj.transform(df)

""" Youâ€™ll build a transformer that:

Computes BMI from weight & height (same as before).

Creates a new column "BMI_category" with labels:

BMI < 18.5 â†’ "Underweight"

18.5 â‰¤ BMI < 25 â†’ "Normal"

25 â‰¤ BMI < 30 â†’ "Overweight"

BMI â‰¥ 30 â†’ "Obese"

Has a parameter return_category_only (default False):

If False â†’ returns weight, height, BMI, and BMI_category.

If True â†’ returns only the "BMI_category" column.
"""

import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin
import numpy as np


df = pd.DataFrame({
    'weight': [50, 72, 90, 110],
    'height': [1.60, 1.80, 1.75, 1.70]
})

class BMICategoryTransformer(BaseEstimator,TransformerMixin):
    def __init__(self,return_category_only=False,weight_col='weight', height_col='height'):
        self.weight_col=weight_col
        self.height_col=height_col
        self.return_category_only=return_category_only

    def fit(self,X,y=None):
        return self

    def transform(self,X,y=None):
      X=X.copy()
      X['BMI']=X[self.weight_col]/X[self.height_col]**2

      conditions = [
        (X['BMI'] < 18.5),
        (X['BMI'] >= 18.5) & (X['BMI'] < 25),
        (X['BMI'] >= 25) & (X['BMI'] < 30),
        (X['BMI'] >= 30)
                  ]
      categories = ['Underweight', 'Normal', 'Overweight', 'Obese']

      X['BMI_category'] = np.select(conditions, categories, default='Unknown')


      return X

obj=BMICategoryTransformer()
obj.transform(df)

"""ðŸ”¹ Advanced Exercise: HealthFeatureTransformer
Goals:

Takes a DataFrame with weight, height, age, gender.

Computes BMI = weight / height^2.

Categorizes BMI into "Underweight", "Normal", "Overweight", "Obese".

Creates a new risk level column based on BMI + age + gender:

If BMI â‰¥ 30 â†’ "High"

If 25 â‰¤ BMI < 30 and age â‰¥ 40 â†’ "Moderate"

Else â†’ "Low"

Handles missing values: if weight or height is missing â†’ fill with median before calculating BMI.

Parameters in __init__:

weight_col, height_col, age_col, gender_col

return_only_features (default False) â†’ returns only BMI, BMI_category, and risk_level.
"""

df = pd.DataFrame({
    'weight': [50, 72, np.nan, 110,70],
    'height': [1.60, 1.80, 1.75, np.nan,1.30],
    'age': [25, 45, 30, 50,60],
    'gender': ['F', 'M', 'M', 'F','F']
})

class  HealthFeatureTransformer(BaseEstimator,TransformerMixin):
  def __init__(self,weight_col='weight',height_col='height',age_col='age',gender_col='gender',return_only_features=False):
    self.weight_col=weight_col
    self.height_col=height_col
    self.age_col=age_col
    self.gender_col=gender_col
    self.return_only_features=return_only_features

  def fit(self,X,y=None):
    self.weight_median_=X[self.weight_col].median()
    self.height_median_=X[self.height_col].median()
    return self


  def transform(self,X,y=None):
    X=X.copy()
    if X[self.weight_col].isnull().sum() != 0:
      X[self.weight_col]=X[self.weight_col].fillna(self.weight_median_)
    if X[self.height_col].isnull().sum() != 0:
      X[self.height_col]=X[self.height_col].fillna(self.height_median_)

    X['BMI']=X[self.weight_col]/X[self.height_col]**2

    conditions = [
        (X['BMI'] < 18.5),
        (X['BMI'] >= 18.5) & (X['BMI'] < 25),
        (X['BMI'] >= 25) & (X['BMI'] < 30),
        (X['BMI'] >= 30)
                  ]
    categories = ['Underweight', 'Normal', 'Overweight', 'Obese']

    X['BMI_category'] = np.select(conditions, categories, default='Unknown')

    conditions = [
        (X['BMI'] < 18.5),
        (X['BMI'] >= 18.5) & (X['BMI'] < 25),
        (X['BMI'] >= 25) & (X['BMI'] < 30) & (X['age']>40),
        (X['BMI'] >= 30)
                  ]

    categories=['Low','Low','Moderate','High']
    X['risk_level']=np.select(conditions,categories,default='Unknown')

    if self.return_only_features:
      return X[['BMI','BMI_category','risk_level']]
    else:
      return X

obj=HealthFeatureTransformer()
obj.fit_transform(df)

df['gender'].mode()

"""ðŸ”¹ Advanced Upgrade: HealthFeaturePipelineTransformer
Goals:

Handle missing values for numeric columns (weight, height, age) â†’ fill with median.

Handle categorical columns (gender, etc.) â†’ fill missing with mode.

Compute derived features:

BMI (weight / height^2)

BMI_category (Underweight, Normal, Overweight, Obese)

Risk level (BMI + age + gender logic)

Keep flexible column names via __init__.

Parameter: return_only_features (default False).

Fully compatible with Pipeline and ColumnTransformer.

Works with any DataFrame with numeric + categorical columns, without assuming exact column order.
"""

df = pd.DataFrame({
    'weight': [50, 72, np.nan, 110],
    'height': [1.60, 1.80, 1.75, np.nan],
    'age': [25, 45, 30, 50],
    'gender': ['F', 'M', 'M', np.nan]
})

class  HealthFeaturePipelineTransformer(BaseEstimator,TransformerMixin):
  def __init__(self,weight_col='weight',height_col='height',age_col='age',gender_col='gender',return_only_features=False):
    self.weight_col=weight_col
    self.height_col=height_col
    self.age_col=age_col
    self.gender_col=gender_col
    self.return_only_features=return_only_features

  def fit(self,X,y=None):
    self.weight_median_=X[self.weight_col].median()
    self.height_median_=X[self.height_col].median()
    self.gender_mode_=X[self.gender_col].mode()[0]
    return self


  def transform(self,X,y=None):
    X=X.copy()
    if X[self.weight_col].isnull().sum() != 0:
      X[self.weight_col]=X[self.weight_col].fillna(self.weight_median_)
    if X[self.height_col].isnull().sum() != 0:
      X[self.height_col]=X[self.height_col].fillna(self.height_median_)

    X['BMI']=X[self.weight_col]/X[self.height_col]**2

    conditions = [
        (X['BMI'] < 18.5),
        (X['BMI'] >= 18.5) & (X['BMI'] < 25),
        (X['BMI'] >= 25) & (X['BMI'] < 30),
        (X['BMI'] >= 30)
                  ]
    categories = ['Underweight', 'Normal', 'Overweight', 'Obese']

    X['BMI_category'] = np.select(conditions, categories, default='Unknown')

    conditions = [
        (X['BMI'] < 18.5),
        (X['BMI'] >= 18.5) & (X['BMI'] < 25),
        (X['BMI'] >= 25) & (X['BMI'] < 30) & (X['age']>40),
        (X['BMI'] >= 30)
                  ]

    categories=['Low','Low','Moderate','High']
    X['risk_level']=np.select(conditions,categories,default='Unknown')

    if self.return_only_features:
      return X[['BMI','BMI_category','risk_level']]
    else:
      return X

obj=HealthFeatureTransformer()
obj.fit_transform(df)